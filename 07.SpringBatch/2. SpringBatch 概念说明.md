# 批处理的域语言

对于任何经验丰富的批处理设计师而言，Spring Batch 中使用的批处理的总体概念应该是熟悉且舒适的。有“工作（Jobs）”和“步骤（Steps）”，以及开发人员提供的处理单元，称为`ItemReader`和`ItemWriter`。但是，由于存在 Spring 模式，操作，模板，回调和惯用语，因此有以下机会：

- 遵守关注点明显分开的情况得到了显着改善。
- 清楚地描述了作为接口提供的体系结构层和服务。
- 简单和默认的实现，可以快速采用和开箱即用。
- 显着增强的可扩展性。

下图是已经使用了数十年的批处理参考体系结构的简化版本。它概述了组成批处理领域语言的组件。Spring Batch提供了层，组件和技术服务的物理实现，这些层，组件和技术服务通常在健壮，可维护的系统中找到，这些系统用于解决从简单到复杂的批处理应用程序的创建，其基础结构和扩展可以满足非常复杂的处理需求。

![图2.1：批处理原型](https://gitee.com/Ep_tassel/typora-image/raw/master/typora/spring-batch-reference-model.png)

上图突出显示了构成 Spring Batch 领域语言的关键概念。一个 Job 有一个到多个 step，每个 step 都只有一个`ItemReader`（用于读取数据），一个`ItemProcessor`（用于处理数据）和一个`ItemWriter`（用于写数据）。一个 job 需要启动（使用 `JobLauncher`），并且存储有关当前正在运行的进程的元数据（位于中 `JobRepository`）。

## Job

本节描述与批处理作业的概念有关的原型，一个 Job 是封装整个批处理过程的实体。与其他 Spring 项目一样，一个 Job 定义在 XML 配置文件中或 Java 配置类中。该配置可以被称为“Job 配置”。Job 位于整个层次结构的顶部，如图 Job 层次机构 所示：

![Job Hierarchy](https://gitee.com/Ep_tassel/typora-image/raw/master/typora/job-heirarchy.png)

在 Spring Batch 中， `Job`只是`Step`实例的容器。它组合了逻辑上属于流程的多个 step，并允许配置所有 step 全局的属性，例如可重新启动性。作业配置包含：

- `Job`的简单名称。
- `Step`实例的定义和顺序。
- `Job`是否可重新启动。

Spring Batch 以`SimpleJob`类的形式提供 Job 接口的默认简单实现，该实现在之上创建了一些标准功能`Job`。使用基于 Java的 配置时，可使用一组构建器来实例化 `Job`，如以下示例所示：

```java
@Bean
public Job footballJob() {
    return this.jobBuilderFactory.get("footballJob")
                     .start(playerLoad())
                     .next(gameLoad())
                     .next(playerSummarization())
                     .end()
                     .build();
}
```

这个配置的意思是：首先给这个 job 起了一个名字叫 footballJob，接着指定了这个 job 的三个 step，他们分别由方法，playerLoad, gameLoad, playerSummarization 实现。

### JobInstance

JobInstance 是指逻辑作业运行的概念。

例如一个应该在一天结束时运行一次的批处理作业，例如上图中的“ EndOfDay”`Job` 。有一个“ EndOfDay” job，但是`Job`必须单独跟踪每次运行。对于这个 job，每天只有一个逻辑上的`JobInstance`。例如，有1月1日运行，1月2日运行，依此类推。如果1月1日运行第一次失败并在第二天再次运行，则仍是1月1日运行。（通常，这也与它正在处理的数据相对应，这意味着1月1日运行处理1月1日的数据）。

因此，每个`JobInstance`可以有多个执行（`JobExecution`本章稍后将详细讨论），并且在给定时间内只能运行一个与特定 Job 相对应并标识`JobParameters`的`JobInstance`。

一个` JobInstance` 的定义一定要与要加载的数据无关。如何加载数据完全取决于`ItemReader`的实现来确定。例如，在`EndOfDay`情景中，数据上可能有一列指示该数据所属的“生效日期”或“计划日期”。因此，1月1日的运行将仅加载第1次的数据，而1月2日的运行将仅使用第2次的数据。由于此确定可能是一项业务决策，因此由 `ItemReader`决定。但是，使用相同的`JobInstance`可以确定是否使用先前执行中的“状态”（即`ExecutionContext`，本章稍后讨论）。使用新的`JobInstance` 意味着“从头开始”，使用现有实例通常意味着“从上次中断的地方开始”。

### JobParameters

在讨论了`JobInstance`与`Job`的不同之处之后，自然要问的问题是：“不同`JobInstance`之间有什么区别？” 答案是： `JobParameters`。一个`JobParameters`对象拥有一组用于启动批处理作业的参数。它们可以在运行期间用于标识甚至用作参考数据，如下图作业参数所示：

![Job Parameters](https://gitee.com/Ep_tassel/typora-image/raw/master/typora/job-stereotypes-parameters.png)

在前面的示例中，有两个实例，一个实例是1月1日，另一个实例是1月2日，实际上只有一个`Job`，但是它有两个`JobParameter`对象：一个对象的作业参数为01-01-2017，另一个对象的参数为01-02-2017。

因此，它们之间的关系可以定义为：
$$
JobInstance = Job + JobParameters
$$
这使开发人员可以有效地控制 `JobInstance`的定义方式，因为他们可以控制传入的参数。

> 并非所有 `job parameters` 都需要有助于识别 `JobInstance`。默认情况下，它们是这样的。但是，该框架还允许使用不对 `JobInstance` 身份识别有贡献的参数提交`Job`。

### JobExecution

一个 `JobExecution`是指一次尝试运行 Job 的技术概念。执行可能以失败或成功结束，但是给定执行相对应的`JobInstance`与除非成功完成，否则视为执行失败。以`Job`前面描述的 EndOfDay 为例，考虑`JobInstance`01-01-2017的首次运行失败。如果使用与第一次运行相同的Jobparameter参数（01-01-2017）作业参数再次运行，`JobExecution`则会创建一个新的实例。但是，仍然只有一个`JobInstance`。

## Step













































































